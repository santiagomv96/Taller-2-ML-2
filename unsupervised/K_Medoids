import numpy as np

class K_Means:

    def __init__(self,X=None,K=None,max_iters=1000):
        self.X=X
        self.K=K
        self.max_iters=max_iters
    
    def fit(self,X,K,max_iters):
        self.X=X
        self.K=K
        self.max_iters=max_iters
        # Inicializar los medoides aleatoriamente
        n = self.X.shape[0]
        medoids_idx = np.random.choice(n, size=self.K, replace=False)
        self.medoids = self.X[medoids_idx, :]

        # Inicializar la asignación de clústeres
        self.labels = np.zeros(n)

        for i in range(self.max_iters):
            # Asignar cada punto al clúster con el medoide más cercano
            # Tomando cada valor y calculando la distancia con el punto del cluster mas cercano
            # Generando una matriz de x,d,k, sobre la que se suman las ditancias de las componentes 
            # y se genera con estas sumas una nueva matriz de X,K que indica la menor distancia 
            distances = np.sum((self.X[:, :, np.newaxis] - self.medoids.T[np.newaxis, :, :]) ** 2, axis=1)
            new_labels = np.argmin(distances, axis=1)

            # Verificar si se alcanzó la convergencia, si no cambia quiere decir que el modelo converge
            #y se hallo la respuesta optima
            if np.array_equal(self.labels, new_labels):
                break

            # Actualizar la asignación de clústeres
            self.labels = new_labels
            self.medoids_idx = np.array([np.where(self.labels == j)[0][np.argmin(distances[:, j])] for j in range(self.k)])
            # Actualizar los medoides
            for j in range(self.K):
                # Obtener los puntos en el clúster j
                # indica los indices de los puntos que pertenecen al cluster
                indices = np.where(self.labels == j)[0]
                #trae los registros de X
                cluster = self.X[indices, :]

                # Calcular la distancia total de cada punto a los demás puntos del clúster
                distances = np.sum((cluster[:, :, np.newaxis] - cluster.T[np.newaxis, :, :]) ** 2, axis=1)

                # Seleccionar el punto con la distancia total más baja como el nuevo medoide
                new_medoid_idx = indices[np.argmin(np.sum(distances, axis=1))]
                self.medoids[j, :] = self.X[new_medoid_idx, :]

    def transform(self,X):
        
        distances = np.sum((X[:, :, np.newaxis] - self.X[self.medoids_idx, :].T[np.newaxis, :, :]) ** 2, axis=1)
        return np.argmin(distances, axis=1)
